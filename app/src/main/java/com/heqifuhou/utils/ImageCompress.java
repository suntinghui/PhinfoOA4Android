package com.heqifuhou.utils;import java.io.ByteArrayOutputStream;import java.io.FileNotFoundException;import java.io.OutputStream;import android.graphics.Bitmap;import android.graphics.Bitmap.CompressFormat;import android.graphics.BitmapFactory;/* options.maxWidth=getWindowManager().getDefaultDisplay().getWidth(); options.maxHeight=getWindowManager().getDefaultDisplay().getHeight();*/public class ImageCompress {	private static final int DEFAULT_WIDTH = 400;	private static final int DEFAULT_HEIGHT = 800;		public static Bitmap compressBitmap(String filePath, int maxW, int maxH) {		if (null == filePath) {			return null;		}		int maxWidth = DEFAULT_WIDTH;		int maxHeight = DEFAULT_HEIGHT;		if (maxW > 0) {			maxWidth = maxW;		}		if (maxH > 0) {			maxHeight = maxH;		}		BitmapFactory.Options options = new BitmapFactory.Options();		options.inJustDecodeBounds = true;		BitmapFactory.decodeFile(filePath, options);		int actualWidth = options.outWidth;		int actualHeight = options.outHeight;		int desiredWidth = getResizedDimension(maxWidth, maxHeight,				actualWidth, actualHeight);		int desiredHeight = getResizedDimension(maxHeight, maxWidth,				actualHeight, actualWidth);		options.inJustDecodeBounds = false;		options.inSampleSize = findBestSampleSize(actualWidth, actualHeight,				desiredWidth, desiredHeight);		Bitmap bitmap = null;		Bitmap destBitmap = BitmapFactory.decodeFile(filePath, options);		// If necessary, scale down to the maximal acceptable size.		if (destBitmap.getWidth() > desiredWidth				|| destBitmap.getHeight() > desiredHeight) {			bitmap = Bitmap.createScaledBitmap(destBitmap, desiredWidth,					desiredHeight, true);			destBitmap.recycle();		} else {			bitmap = destBitmap;		}		return bitmap;	}	private static int findBestSampleSize(int actualWidth, int actualHeight,			int desiredWidth, int desiredHeight) {		double wr = (double) actualWidth / desiredWidth;		double hr = (double) actualHeight / desiredHeight;		double ratio = Math.min(wr, hr);		float n = 1.0f;		while ((n * 2) <= ratio) {			n *= 2;		}		return (int) n;	}	private static int getResizedDimension(int maxPrimary, int maxSecondary,			int actualPrimary, int actualSecondary) {		// If no dominant value at all, just return the actual.		if (maxPrimary == 0 && maxSecondary == 0) {			return actualPrimary;		}		// If primary is unspecified, scale primary to match secondary's scaling		// ratio.		if (maxPrimary == 0) {			double ratio = (double) maxSecondary / (double) actualSecondary;			return (int) (actualPrimary * ratio);		}		if (maxSecondary == 0) {			return maxPrimary;		}		double ratio = (double) actualSecondary / (double) actualPrimary;		int resized = maxPrimary;		if (resized * ratio > maxSecondary) {			resized = (int) (maxSecondary / ratio);		}		return resized;	}	}